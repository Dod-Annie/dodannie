### This file was autogenerated by Nexus 0.11.6
### Do not make changes to this file directly


type AggregateUser {
  count: Int!
}

type AggregateVip {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Logged {
  """登录失败原因"""
  error: String!

  """登录成功"""
  success: Boolean!
}

scalar Long

type Mutation {
  createUser(data: UserCreateInput!): User!
  createVip(data: VipCreateInput!): Vip!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deleteManyVips(where: VipWhereInput): BatchPayload!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteVip(where: VipWhereUniqueInput!): Vip
  Login(password: String!, userName: String!): Logged!
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateManyVips(data: VipUpdateManyMutationInput!, where: VipWhereInput): BatchPayload!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateVip(data: VipUpdateInput!, where: VipWhereUniqueInput!): Vip
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertVip(create: VipCreateInput!, update: VipUpdateInput!, where: VipWhereUniqueInput!): Vip!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  user(where: UserWhereUniqueInput!): User
  users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  usersConnection(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): UserConnection!
  vip(where: VipWhereUniqueInput!): Vip
  vips(after: String, before: String, first: Int, last: Int, orderBy: VipOrderByInput, skip: Int, where: VipWhereInput): [Vip!]!
  vipsConnection(after: String, before: String, first: Int, last: Int, orderBy: VipOrderByInput, skip: Int, where: VipWhereInput): VipConnection!
}

type User {
  id: ID!
  isVip: Boolean!
  password: String!
  realName: String!
  userName: String!
  vip: Vip
}

type UserConnection {
  aggregate: AggregateUser!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

input UserCreateInput {
  isVip: Boolean
  password: String!
  realName: String!
  userName: String!
  vip: VipCreateOneWithoutOwnerInput
}

input UserCreateOneWithoutVipInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutVipInput
}

input UserCreateWithoutVipInput {
  isVip: Boolean
  password: String!
  realName: String!
  userName: String!
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  isVip_ASC
  isVip_DESC
  password_ASC
  password_DESC
  realName_ASC
  realName_DESC
  updatedAt_ASC
  updatedAt_DESC
  userName_ASC
  userName_DESC
}

input UserUpdateInput {
  isVip: Boolean
  password: String
  realName: String
  userName: String
  vip: VipUpdateOneWithoutOwnerInput
}

input UserUpdateManyMutationInput {
  isVip: Boolean
  password: String
  realName: String
  userName: String
}

input UserUpdateOneWithoutVipInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutVipInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutVipDataInput
  upsert: UserUpsertWithoutVipInput
}

input UserUpdateWithoutVipDataInput {
  isVip: Boolean
  password: String
  realName: String
  userName: String
}

input UserUpsertWithoutVipInput {
  create: UserCreateWithoutVipInput!
  update: UserUpdateWithoutVipDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  isVip: Boolean
  isVip_not: Boolean
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  realName: String
  realName_contains: String
  realName_ends_with: String
  realName_gt: String
  realName_gte: String
  realName_in: [String!]
  realName_lt: String
  realName_lte: String
  realName_not: String
  realName_not_contains: String
  realName_not_ends_with: String
  realName_not_in: [String!]
  realName_not_starts_with: String
  realName_starts_with: String
  userName: String
  userName_contains: String
  userName_ends_with: String
  userName_gt: String
  userName_gte: String
  userName_in: [String!]
  userName_lt: String
  userName_lte: String
  userName_not: String
  userName_not_contains: String
  userName_not_ends_with: String
  userName_not_in: [String!]
  userName_not_starts_with: String
  userName_starts_with: String
  vip: VipWhereInput
}

input UserWhereUniqueInput {
  id: ID
  userName: String
}

type Vip {
  id: ID!
  level: Int
  owner: User
  title: String
}

type VipConnection {
  aggregate: AggregateVip!
  edges: [VipEdge!]!
  pageInfo: PageInfo!
}

input VipCreateInput {
  level: Int
  owner: UserCreateOneWithoutVipInput
  title: String
}

input VipCreateOneWithoutOwnerInput {
  connect: VipWhereUniqueInput
  create: VipCreateWithoutOwnerInput
}

input VipCreateWithoutOwnerInput {
  level: Int
  title: String
}

type VipEdge {
  cursor: String!
  node: Vip!
}

enum VipOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  level_ASC
  level_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input VipUpdateInput {
  level: Int
  owner: UserUpdateOneWithoutVipInput
  title: String
}

input VipUpdateManyMutationInput {
  level: Int
  title: String
}

input VipUpdateOneWithoutOwnerInput {
  connect: VipWhereUniqueInput
  create: VipCreateWithoutOwnerInput
  delete: Boolean
  disconnect: Boolean
  update: VipUpdateWithoutOwnerDataInput
  upsert: VipUpsertWithoutOwnerInput
}

input VipUpdateWithoutOwnerDataInput {
  level: Int
  title: String
}

input VipUpsertWithoutOwnerInput {
  create: VipCreateWithoutOwnerInput!
  update: VipUpdateWithoutOwnerDataInput!
}

input VipWhereInput {
  AND: [VipWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  level: Int
  level_gt: Int
  level_gte: Int
  level_in: [Int!]
  level_lt: Int
  level_lte: Int
  level_not: Int
  level_not_in: [Int!]
  NOT: [VipWhereInput!]
  OR: [VipWhereInput!]
  owner: UserWhereInput
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
}

input VipWhereUniqueInput {
  id: ID
}
